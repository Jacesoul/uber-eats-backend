### INTRODUCTION

- nest g application
- gitignore extension 설치

### GraphQl API

- npm i @nestjs/graphql graphql@^15 apollo-server-express
- app.module.ts는 main.ts로 import되는 유일한 모듈이다. 
- main.ts는 application을 실행시키기 위한 것이다. 그러니 모든것들은 결국에 AppModule로 import된다.
- forRoot는 root module을 설정하는것이다. 이 경우에는 GraphQl이 forRoot에 해당한다.
- GraphQl Query는 첫번째 argument로 function이 필요하다.   
- autoSchemaFile: true로 설정하면 메모리에 sche ma.graphql파일이 생성된다.
- InputType은 그저 하나의 object로 보면된다. argument로써 graphql에 전달하기 위한 용도이다. 
- ArgsType은 기본적으로 하나의 object에 모든것을 담지 않고 GraphQl argument로 전달해 줄수 있도록 해준다.
- npm i class-validator class-transformer

### Database Configuration

- TypeORM은 Object Relational Mapping(객체 관계 매핑)이란 뜻이다. 
- PostgreSQL 설치 
- https://postgresapp.com/
- Postico 설치 (데이터베이스 시각화 툴)
- https://eggerapps.at/postico/
- 데이터베이스 생성 => uber-eats
- 데이터베이스 터미널에서 유저명과 비밀번호 변경 
- \du; => 모든 유저확인 
- ALTER USER 'jiwooseol' WITH PASSWORD '12345'
- TypeORM이 Sequelize보다 TypeScript에 더 친화적이다.
- npm install --save @nestjs/typeorm typeorm pg
- localhost로 연결이 되어있을때는 PostgreSQL가 패스워드를 물어보지 않는다.
- synchronize: true는 TypeORM이 데이터베이스에 연결할때 데이터베이스를 모듈의 현재 상태로 마이그래에션한다는 뜻이다.
- logging은 데이터베이스에서 무슨일이 일어나는지 콜솔에 표시하는것이다.
- dotenv는 .env 파일에서 환경변수를 로드하는데 process.env."환경변수이름" 방식으로 그 변수에 접근할수 있다. 
- NestJS는 configuration module이 있는데 dotenv의 최상위에서 실행이 된다. 
- npm i --save @nestjs/config
- ConfigModuleOptions의 isGlobal은 어플리케이션 어디서나 config 모듈에 접근할수 있다는것이다.
- .env.test/ .env.dev / .env.prod 파일 생성
- cross-env는 가상변수를 설정할수 있게 해주는데 MacOS, Windows, Linux에 관계없이 사용할수 있다. 
- npm i cross-env
- ignoreEnvFile은 서버에 deploy할때 환경변수 파일을 사용하지 않는다는것이다. 
- ConfigModuleOptions의 validationSchema는 원하는 모든 환경변수를 validate할수 있다. 
- joi는 자바스크립트용의 가장 강력한 스키마 설명 언어이자 데이터 유효성 검사 툴이다.
- npm i joi
- import * as Joi from 'joi'; 은 타입스크립트나 NestJS로 되어있지 않은 패키지를 import 하는 방법이다.
- Joi 덕분에 환경변수 마저도 그 유효성 검사를 할수 있어서 앱을 돌릴때 더 좋은 보안을 제공한다.
- TypeOrm의 Entity는 데이터베이스를에 저장되는 데이터의 형태를 보여주는 모델이다. 
- Entity는 DB table(MongoDB를 사용하는 경우 collection)에 매핑되는 클래스이다.
- ObjectType은 자동으로 스키마를 빌드하기 위해 사용하는 GraphQl decorator이다.
- ObjectType과 Entity는 같이 사용될수 있다.
- Data Mapper에서는 Repository라는것을 사용한다. Repository는 Entity랑 상호작용하는것을 담당한다.
- Data Mapper는 유지관리하는것을 도와주고 대규모 앱에서 유용하다.
- Active Record는 소규모 앱에서 단순하게 사용할 수 있도록 도와준다.
- NestJS 어플리케이션에서 Data Mapper를 사용하려는 이유는 Nest+TypeORM 개발환경에서 Repository를 사용하는 모듈을 쓸수 있기 때문이다. 
- Repository를 사용하면 어디서든지 접근할수가 있다. 실제로 구현하는 서비스에서도 접근이 가능하고 테스팅할 때도 접근이 가능하다.
- Data Mapper 패턴을 이용해서 Repository를 test하고 simulate해볼 수 있다.
- method는 class안에 있는 function이다.
- Repository.create()는 DB는 건드리지 않고 새로운 instance를 생성한다.
- DB에 저장하고 싶다면 save method를 사용해야한다.
- Mapped Types는 base type을 바탕으로 다른 버전들을 만들수 있게 해준다.
- Mapped Types에는 4가지의 타입이 있다. Partial, Pick, Omit, Intersection
- Partial type은 base type, base class를 가져다가 export하고 모든 field가 required가 아닌 class를 만들어준다.
- Pick type은 input type에서 몇가지 property를 선택해 새로운 class를 만들어준다.
- Omit type은 base class에서 class를 만드는데 몇몇 field를 제외하고 만드는것이다.
- Intersection type은 두 input을 합쳐주는 역할을 한다.
- [에러]GraphQLError [Object]: Input Object type CreateRestaurantDto must define one or more fields.
- 상단의 에러가 나오는 이유는 DTO에서 Mapped type을 사용하기위해서는 entity도 Input type을 사용해야한다. Mapped type의 마지막 인자에 InputType을 입력해주면 entity의 데코레이터를 변경할수있다. 이렇게 명시하지 않으면 child class는 parent class와 같은 데코레이터를 사용하게된다.
- 다른 방법으로는 entity에 @InputType({ isAbstract: true }) 데코레이터를 넣어줄수 있다. isAbstract: true의 의미는 이 InputType이 스키마에 포함되지 않길 원한다는 것이다.
- abstract는 직접 쓰는게 아니라 어떤것으로 확장시킨다는 의미이다.
- default value VS nullable value
- default value는 내가 isVegan을 정의해주지 않는 이상 isVegan은 true로 나온다.
- nullable value은 isVegan의 결과가 나오지 않는다. 
- DTO에서 InputType을 사용한다면 argument에 이름이 있어야한다. ArgsType을 쓴다면 비워놓아야한다. 
- update()가 Promise를 return한다는건 매우 중요하다. DB에 entity가 있는지 없는지 확인하지 않고 update query를 실행한다. 존재하지 않는 id를 넣더라도 에러가 나오지 않는다.


### USER CRUD

- CreateDateColumn, UpdateDateColumn은 entity를 만들었을때 자동으로 설정해주는 special column이다. 
- hash는 단방향 함수(one-way function)이다.
- listener는 기본적으로 entity에 무슨일이 생길때 실행되는것이다.
- npm i bcrypt
- npm i @types/bcrypt --dev-only

### USER AUTHENTICATION

- npm i jsonwebtoken
- npm i @types/jsonwebtoken --only-dev
- jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
- 사용자는 본인의 token안에 무엇이 들어가 있는지 볼수있다.(토큰에 들어있는 암호를 해독가능하다)
- sign의 첫번째 인자에는 중요한 정보를 넣지 않고 어떤 회원인지 알수 있는 id를 넣는게 좋다.
- privateKey를 이용해서 token을 지정해주는 목적은 사용자가 token을 수정했는지 확인할수 있기 때문이다. 
- Config module을 설치 및 설정하고 configService를 요청하게 되면 nestjs가 이미 configModule의 존재를 인지하고 필요한 정보를 전달해준다. 그저 constructor에서 요청하기만 하면 된다.
- dependency injection은 우리가 원하는 것의 class만 적어주면 nestjs가 그 정보를 가져다준다.
- jsonwebtoken을 사용하는 이유는 만들고 있는 서비스만의 유효한 인증을 할수있게 하는것이다.(내부에 담겨진 정보자체가 아닌, 정보의 진위여부가 중요하다)
- Module에는 static모듈과 dynamic 모듈이 있다.
- dynamic모듈은 설정이 적용되어 있는 모듈이다. static모듈은 어떤한 설정도 적용되어 있지 않다.
- dynamic모듈은 또 다른 module을 반환해주는 모듈이다.